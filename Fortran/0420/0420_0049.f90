MODULE M
  TYPE T
      INTEGER::A
     CONTAINS 
        PROCEDURE::SUB
        PROCEDURE::SUB1
        GENERIC::WRITE(FORMATTED)=>SUB
        GENERIC::READ(FORMATTED)=>SUB1
END TYPE T
CHARACTER(14) :: CH
  INTEGER :: VV
INTEGER,ALLOCATABLE ::ARR(:)

CONTAINS
SUBROUTINE SUB (DTV, UNIT, IOTYPE, V_LIST, IOSTAT,IOMSG)
    CLASS(T), INTENT(IN)            :: DTV
    INTEGER, INTENT(IN)            :: UNIT
    CHARACTER(LEN=*), INTENT(IN)    :: IOTYPE
    INTEGER, INTENT(IN)             :: V_LIST (:)
    INTEGER, INTENT(OUT)            :: IOSTAT
    CHARACTER(LEN=*), INTENT(INOUT) :: IOMSG
    VV=DTV%A
    IF(SIZE(V_LIST)/=0) THEN
        WRITE(UNIT,*,IOSTAT=IOSTAT,IOMSG=IOMSG) V_LIST(1),V_LIST(2),DTV%A+1,IOTYPE
      ELSE
        WRITE(UNIT,*,IOSTAT=IOSTAT,IOMSG=IOMSG) DTV%A+1
      END IF    
    END SUBROUTINE SUB

SUBROUTINE SUB1 (DTV, UNIT, IOTYPE, V_LIST, IOSTAT, IOMSG)
    CLASS(T), INTENT(INOUT)            :: DTV
    INTEGER, INTENT(IN)             :: UNIT
    CHARACTER(LEN=*), INTENT(IN)    :: IOTYPE
    INTEGER, INTENT(IN)             :: V_LIST (:)
    INTEGER, INTENT(OUT)            :: IOSTAT
    CHARACTER(LEN=*), INTENT(INOUT) :: IOMSG
ALLOCATE(ARR,SOURCE=V_LIST)
  CH=IOTYPE
          IF(SIZE(V_LIST)/=0) THEN
         VV=V_LIST(1)
        READ(UNIT,*,IOSTAT=IOSTAT,IOMSG=IOMSG) DTV%A,CH
      ELSE
        READ(UNIT,*,IOSTAT=IOSTAT,IOMSG=IOMSG) DTV%A,CH
     END IF
     DTV%A=DTV%A+1
END SUBROUTINE SUB1

END MODULE M

PROGRAM MAIN

USE M
TYPE(T)::OBJW,OBJR
CHARACTER(len=20)::C(500)
character(1000):: msg
integer::ios
OBJR%A=14
OBJW%A=4
ios=-1000
     WRITE(C,*,IOSTAT=ios,iomsg=msg)OBJW  
if (ios==0) print *,101
if(VV .ne. 4)print*,101
CH='garbage'
ios=-1000
   READ (C,*,IOSTAT=ios,iomsg=msg)OBJR
if (ios==0) print *,102
print *,'pass'

END PROGRAM
